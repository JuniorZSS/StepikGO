package String

import (
	"fmt"
	"strings"
	"unicode"
)

func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов, но её длина в байтах будет 19,
	// так как кириллические символы занимают 2 байта, а пробел — 1 байт.
	var s string = "Это строка"

	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Получим подстроку строки
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	// Попробуем изменить строку (возникнет ошибка компиляции, так как строки неизменяемы):
	// s[3] = 12
	// Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.

	// "Изменим строку", создав новую строку
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// Проитерируемся по строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072
}

func ExampleEqualString() {
	// Сравнение строк на равенство
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")

	// Сравнение строк на неравенство
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	// Сравнение строк по алфавиту
	fmt.Printf("\"Строка1\" > \"Строка2\": %v\n", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}

func ExampleStrings() {
	fmt.Println(
		// Содержится ли подстрока в строке
		strings.Contains("test", "es"),
		// результат: true

		// Кол-во подстрок в строке
		strings.Count("test", "t"),
		// результат: 2

		// Начинается ли строка с префикса
		strings.HasPrefix("test", "te"),
		// результат: true

		// Заканчивается ли строка суффиксом
		strings.HasSuffix("test", "st"),
		// результат: true

		// Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
		strings.Index("test", "e"),
		// результат: 1

		// объединяет массив строк через символ
		strings.Join([]string{"hello", "world"}, "-"),
		// результат: "hello-world"

		// Повторяет строку n раз подряд
		strings.Repeat("a", 5),
		// результат: "aaaaa"

		// Функция Replace заменяет любое вхождение old в вашей строке на new
		// Если значение n равно -1, то будут заменены все вхождения.
		// Общий вид: func Replace(s, old, new string, n int) string
		// Пример:
		strings.Replace("blanotblanot", "not", "***", -1),
		// результат: "bla***bla***"

		// Разбивает строку согласно разделителю
		strings.Split("a-b-c-d-e", "-"),
		// результат: []string{"a","b","c","d","e"}

		// Возвращает строку c нижним регистром
		strings.ToLower("TEST"),
		// результат: "test"

		// Возвращает строку c верхним регистром
		strings.ToUpper("test"),
		// результат: "TEST"

		// Возвращает строку с вырезанным набором
		strings.Trim("tetstet", "te"),
		// результат: s
	)
}

func ExampleByteSlice() {
	// Используем строку, которую конвертируем в []byte,
	// чтобы показать, как выглядит байтовый срез.
	bs := []byte("Это байтовый срез")

	// Печатаем байтовый срез.
	fmt.Printf("Так байтовый срез выглядит внутри: %v\n", bs)

	// Демонстрируем, что байтовый срез можно изменять,
	// а затем выводим его в виде строки.
	for i := range bs {
		// Для чётных байтов увеличиваем на 1, для нечётных уменьшаем на 1.
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
		} else {
			bs[i] = bs[i] - 1
		}
	}

	// Печатаем изменённый байтовый срез в виде строки.
	fmt.Printf("Изменённый байтовый срез в виде строки: %s", bs)

	// Output:
	// Так байтовый срез выглядит внутри: [208 173 209 130 208 190 32 208 177 208 176 208 185 209 130 208 190 208 178 209 139 208 185 32 209 129 209 128 208 181 208 183]
	// Изменённый байтовый срез в виде строки: ѬЃѿ!ѰѱѸЃѿѳЊѸ!ЀЁѴѶ
}

func ExampleRune() {
	// Преобразуем строку в срез рун
	rs := []rune("Это срез рун")

	// Итерируемся по срезу рун и заменяем символ 'р' на '*'
	for i := range rs {
		if rs[i] == 'р' {
			rs[i] = '*'
		}
	}

	// Выводим изменённый срез в виде строки
	fmt.Printf("Изменённый срез в виде строки: %s\n", string(rs))

	// Output:
	// Изменённый срез в виде строки: Это с*ез *ун
}

func ExampleUnicode() {
	// функции ниже принимают на вход тип rune
	fmt.Println("Информация по Юникоду, полезно применять для проверок (Какое значение дали на вход?)")

	// проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
	// проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true
	// проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
	// проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
	// проверка символа на пробел
	// пробел это не только ' ', но и:
	//  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true

	// С помощью функции Is можно проверять на кастомный RangeTable:
	// например, проверка на латиницу:
	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false

	// функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F

	fmt.Println("Подробная документация по Юникоду: https://pkg.go.dev/unicode")
}

func Task1() {
	fmt.Println("Теория по строкам из курса", "\nВыбери теорию: 1 - ExampleString, 2 - ExampleEqualString, 3 - SeedStrings и т.д ... ")
	var changer int
	fmt.Scan(&changer)
	switch changer {
	case 1:
		ExampleString()
	case 2:
		ExampleEqualString()
	case 3:
		ExampleStrings()
	case 4:
		ExampleByteSlice()
	case 5:
		ExampleRune()
	case 6:
		ExampleUnicode()

	default:
		fmt.Println("Такого нету")
	}

}
